.. module:: exoplanet

.. note:: This tutorial was generated from an IPython notebook that can be
          downloaded `here <../../_static/notebooks/transit.ipynb>`_.

.. _transit:



Transit fitting
===============

*exoplanet* includes methods for computing the light curves transiting
planets. In its simplest form this can be used to evaluate a light curve
like you would do with
`batman <https://astro.uchicago.edu/~kreidberg/batman/>`__, for example:

.. code:: python

    import numpy as np
    import matplotlib.pyplot as plt
    
    import exoplanet as xo
    
    # The light curve calculation requires an orbit
    orbit = xo.orbits.KeplerianOrbit(period=3.456)
    
    # Compute a limb-darkened light curve using starry
    t = np.linspace(-0.1, 0.1, 1000)
    u = [0.3, 0.2]
    light_curve = (
        xo.LimbDarkLightCurve(u)
        .get_light_curve(orbit=orbit, r=0.1, t=t, texp=0.02)
        .eval()
    )
    # Note: the `eval` is needed because this is using Theano in
    # the background
    
    plt.plot(t, light_curve, color="C0", lw=2)
    plt.ylabel("relative flux")
    plt.xlabel("time [days]")
    _ = plt.xlim(t.min(), t.max())



.. image:: transit_files/transit_4_0.png


But the real power comes from the fact that this is defined as a `Theano
operation <http://deeplearning.net/software/theano/extending/extending_theano.html>`__
so it can be combined with PyMC3 to do transit inference using
Hamiltonian Monte Carlo.

The transit model in PyMC3
--------------------------

In this section, we will construct a simple transit fit model using
*PyMC3* and then we will fit a two planet model to simulated data. To
start, let’s randomly sample some periods and phases and then define the
time sampling:

.. code:: python

    np.random.seed(123)
    periods = np.random.uniform(5, 20, 2)
    t0s = periods * np.random.rand(2)
    t = np.arange(0, 80, 0.02)
    yerr = 5e-4

Then, define the parameters. In this simple model, we’ll just fit for
the limb darkening parameters of the star, and the period, phase, impact
parameter, and radius ratio of the planets (note: this is already 10
parameters and running MCMC to convergence using
`emcee <https://emcee.readthedocs.io>`__ would probably take at least an
hour). For the limb darkening, we’ll use a quadratic law as
parameterized by `Kipping (2013) <https://arxiv.org/abs/1308.0009>`__.
This reparameterizations is implemented in *exoplanet* as custom *PyMC3*
distribution :class:`exoplanet.distributions.QuadLimbDark`.

.. code:: python

    import pymc3 as pm
    
    with pm.Model() as model:
    
        # The baseline flux
        mean = pm.Normal("mean", mu=0.0, sd=1.0)
    
        # The time of a reference transit for each planet
        t0 = pm.Normal("t0", mu=t0s, sd=1.0, shape=2)
    
        # The log period; also tracking the period itself
        logP = pm.Normal("logP", mu=np.log(periods), sd=0.1, shape=2)
        period = pm.Deterministic("period", pm.math.exp(logP))
    
        # The Kipping (2013) parameterization for quadratic limb darkening paramters
        u = xo.distributions.QuadLimbDark("u", testval=np.array([0.3, 0.2]))
    
        r = pm.Uniform(
            "r", lower=0.01, upper=0.1, shape=2, testval=np.array([0.04, 0.06])
        )
        b = xo.distributions.ImpactParameter(
            "b", ror=r, shape=2, testval=np.random.rand(2)
        )
    
        # Set up a Keplerian orbit for the planets
        orbit = xo.orbits.KeplerianOrbit(period=period, t0=t0, b=b)
    
        # Compute the model light curve using starry
        light_curves = xo.LimbDarkLightCurve(u).get_light_curve(
            orbit=orbit, r=r, t=t
        )
        light_curve = pm.math.sum(light_curves, axis=-1) + mean
    
        # Here we track the value of the model light curve for plotting
        # purposes
        pm.Deterministic("light_curves", light_curves)
    
        # In this line, we simulate the dataset that we will fit
        y = xo.eval_in_model(light_curve)
        y += yerr * np.random.randn(len(y))
    
        # The likelihood function assuming known Gaussian uncertainty
        pm.Normal("obs", mu=light_curve, sd=yerr, observed=y)
    
        # Fit for the maximum a posteriori parameters given the simuated
        # dataset
        map_soln = xo.optimize(start=model.test_point)


.. parsed-literal::

    optimizing logp for variables: [b, r, u, logP, t0, mean]
    100it [00:06, 15.76it/s, logp=2.479354e+04]
    message: Desired error not necessarily achieved due to precision loss.
    logp: 24787.977771807487 -> 24793.53942561119


Now we can plot the simulated data and the maximum a posteriori model to
make sure that our initialization looks ok.

.. code:: python

    plt.plot(t, y, ".k", ms=4, label="data")
    for i, l in enumerate("bc"):
        plt.plot(
            t, map_soln["light_curves"][:, i], lw=1, label="planet {0}".format(l)
        )
    plt.xlim(t.min(), t.max())
    plt.ylabel("relative flux")
    plt.xlabel("time [days]")
    plt.legend(fontsize=10)
    _ = plt.title("map model")



.. image:: transit_files/transit_10_0.png


Sampling
--------

Now, let’s sample from the posterior defined by this model. As usual,
there are strong covariances between some of the parameters so we’ll use
:func:`exoplanet.get_dense_nuts_step`.

.. code:: python

    np.random.seed(42)
    with model:
        trace = pm.sample(
            tune=3000,
            draws=3000,
            start=map_soln,
            cores=2,
            chains=2,
            step=xo.get_dense_nuts_step(target_accept=0.9),
        )


.. parsed-literal::

    Multiprocess sampling (2 chains in 2 jobs)
    NUTS: [b, r, u, logP, t0, mean]
    Sampling 2 chains, 0 divergences: 100%|██████████| 12000/12000 [01:36<00:00, 123.89draws/s]


After sampling, it’s important that we assess convergence. We can do
that using the ``pymc3.summary`` function:

.. code:: python

    pm.summary(trace, varnames=["period", "t0", "r", "b", "u", "mean"])




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>mean</th>
          <th>sd</th>
          <th>hpd_3%</th>
          <th>hpd_97%</th>
          <th>mcse_mean</th>
          <th>mcse_sd</th>
          <th>ess_mean</th>
          <th>ess_sd</th>
          <th>ess_bulk</th>
          <th>ess_tail</th>
          <th>r_hat</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>period[0]</th>
          <td>15.448</td>
          <td>0.002</td>
          <td>15.443</td>
          <td>15.452</td>
          <td>0.000</td>
          <td>0.000</td>
          <td>1973.0</td>
          <td>1973.0</td>
          <td>2219.0</td>
          <td>3072.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>period[1]</th>
          <td>9.292</td>
          <td>0.000</td>
          <td>9.292</td>
          <td>9.293</td>
          <td>0.000</td>
          <td>0.000</td>
          <td>5339.0</td>
          <td>5339.0</td>
          <td>5522.0</td>
          <td>4097.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>t0[0]</th>
          <td>3.503</td>
          <td>0.006</td>
          <td>3.494</td>
          <td>3.515</td>
          <td>0.000</td>
          <td>0.000</td>
          <td>1927.0</td>
          <td>1926.0</td>
          <td>2080.0</td>
          <td>3193.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>t0[1]</th>
          <td>5.121</td>
          <td>0.001</td>
          <td>5.119</td>
          <td>5.124</td>
          <td>0.000</td>
          <td>0.000</td>
          <td>6331.0</td>
          <td>6330.0</td>
          <td>6492.0</td>
          <td>3902.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>r[0]</th>
          <td>0.040</td>
          <td>0.002</td>
          <td>0.037</td>
          <td>0.042</td>
          <td>0.000</td>
          <td>0.000</td>
          <td>2948.0</td>
          <td>2948.0</td>
          <td>3004.0</td>
          <td>3249.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>r[1]</th>
          <td>0.058</td>
          <td>0.001</td>
          <td>0.057</td>
          <td>0.060</td>
          <td>0.000</td>
          <td>0.000</td>
          <td>2580.0</td>
          <td>2580.0</td>
          <td>2609.0</td>
          <td>3801.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>b[0]</th>
          <td>0.671</td>
          <td>0.046</td>
          <td>0.581</td>
          <td>0.739</td>
          <td>0.001</td>
          <td>0.001</td>
          <td>1709.0</td>
          <td>1709.0</td>
          <td>1957.0</td>
          <td>2716.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>b[1]</th>
          <td>0.402</td>
          <td>0.038</td>
          <td>0.334</td>
          <td>0.472</td>
          <td>0.001</td>
          <td>0.001</td>
          <td>2606.0</td>
          <td>2606.0</td>
          <td>2745.0</td>
          <td>2906.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>u[0]</th>
          <td>0.375</td>
          <td>0.209</td>
          <td>0.002</td>
          <td>0.717</td>
          <td>0.003</td>
          <td>0.002</td>
          <td>4195.0</td>
          <td>4155.0</td>
          <td>4108.0</td>
          <td>3492.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>u[1]</th>
          <td>0.273</td>
          <td>0.343</td>
          <td>-0.327</td>
          <td>0.842</td>
          <td>0.007</td>
          <td>0.005</td>
          <td>2663.0</td>
          <td>2348.0</td>
          <td>2584.0</td>
          <td>2841.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>mean</th>
          <td>0.000</td>
          <td>0.000</td>
          <td>-0.000</td>
          <td>0.000</td>
          <td>0.000</td>
          <td>0.000</td>
          <td>7178.0</td>
          <td>3124.0</td>
          <td>7182.0</td>
          <td>3887.0</td>
          <td>1.0</td>
        </tr>
      </tbody>
    </table>
    </div>



That looks pretty good! Fitting this without *exoplanet* would have
taken a lot more patience.

Now we can also look at the `corner
plot <https://corner.readthedocs.io>`__ of some of that parameters of
interest:

.. code:: python

    import corner
    
    samples = pm.trace_to_dataframe(trace, varnames=["period", "r"])
    truth = np.concatenate(
        xo.eval_in_model([period, r], model.test_point, model=model)
    )
    _ = corner.corner(
        samples,
        truths=truth,
        labels=["period 1", "period 2", "radius 1", "radius 2"],
    )



.. image:: transit_files/transit_16_0.png


Phase plots
-----------

Like in the radial velocity tutorial (:ref:`rv`), we can make plots of
the model predictions for each planet.

.. code:: python

    for n, letter in enumerate("bc"):
        plt.figure()
    
        # Get the posterior median orbital parameters
        p = np.median(trace["period"][:, n])
        t0 = np.median(trace["t0"][:, n])
    
        # Compute the median of posterior estimate of the contribution from
        # the other planet. Then we can remove this from the data to plot
        # just the planet we care about.
        other = np.median(trace["light_curves"][:, :, (n + 1) % 2], axis=0)
    
        # Plot the folded data
        x_fold = (t - t0 + 0.5 * p) % p - 0.5 * p
        plt.errorbar(
            x_fold, y - other, yerr=yerr, fmt=".k", label="data", zorder=-1000
        )
    
        # Plot the folded model
        inds = np.argsort(x_fold)
        inds = inds[np.abs(x_fold)[inds] < 0.3]
        pred = trace["light_curves"][:, inds, n] + trace["mean"][:, None]
        pred = np.median(pred, axis=0)
        plt.plot(x_fold[inds], pred, color="C1", label="model")
    
        # Annotate the plot with the planet's period
        txt = "period = {0:.4f} +/- {1:.4f} d".format(
            np.mean(trace["period"][:, n]), np.std(trace["period"][:, n])
        )
        plt.annotate(
            txt,
            (0, 0),
            xycoords="axes fraction",
            xytext=(5, 5),
            textcoords="offset points",
            ha="left",
            va="bottom",
            fontsize=12,
        )
    
        plt.legend(fontsize=10, loc=4)
        plt.xlim(-0.5 * p, 0.5 * p)
        plt.xlabel("time since transit [days]")
        plt.ylabel("relative flux")
        plt.title("planet {0}".format(letter))
        plt.xlim(-0.3, 0.3)



.. image:: transit_files/transit_18_0.png



.. image:: transit_files/transit_18_1.png


Citations
---------

As described in the :ref:`citation` tutorial, we can use
:func:`exoplanet.citations.get_citations_for_model` to construct an
acknowledgement and BibTeX listing that includes the relevant citations
for this model. This is especially important here because we have used
quite a few model components that should be cited.

.. code:: python

    with model:
        txt, bib = xo.citations.get_citations_for_model()
    print(txt)


.. parsed-literal::

    This research made use of \textsf{exoplanet} \citep{exoplanet} and its
    dependencies \citep{exoplanet:agol19, exoplanet:astropy13, exoplanet:astropy18,
    exoplanet:exoplanet, exoplanet:kipping13, exoplanet:luger18, exoplanet:pymc3,
    exoplanet:theano}.


.. code:: python

    print("\n".join(bib.splitlines()[:10]) + "\n...")


.. parsed-literal::

    
    @misc{exoplanet:exoplanet,
      author = {Daniel Foreman-Mackey and Rodrigo Luger and Ian Czekala and
                Eric Agol and Adrian Price-Whelan and Tom Barclay},
       title = {exoplanet-dev/exoplanet v0.3.1},
       month = may,
        year = 2020,
         doi = {10.5281/zenodo.1998447},
         url = {https://doi.org/10.5281/zenodo.1998447}
    }
    ...


