.. module:: exoplanet

.. note:: This tutorial was generated from an IPython notebook that can be
          downloaded `here <../../_static/notebooks/rv.ipynb>`_.

.. _rv:



Radial velocity fitting
=======================

In this tutorial, we will demonstrate how to fit radial velocity
observations of an exoplanetary system using *exoplanet*. We will follow
`the getting started
tutorial <https://radvel.readthedocs.io/en/latest/tutorials/K2-24_Fitting+MCMC.html>`__
from `the exellent RadVel package <https://radvel.readthedocs.io>`__
where they fit for the parameters of the two planets in `the K2-24
system <https://arxiv.org/abs/1511.04497>`__.

First, let’s download the data from RadVel:

.. code:: python

    import numpy as np
    import pandas as pd
    import matplotlib.pyplot as plt
    
    url = "https://raw.githubusercontent.com/California-Planet-Search/radvel/master/example_data/epic203771098.csv"
    data = pd.read_csv(url, index_col=0)
    
    x = np.array(data.t)
    y = np.array(data.vel)
    yerr = np.array(data.errvel)
    
    # Compute a reference time that will be used to normalize the trends model
    x_ref = 0.5 * (x.min() + x.max())
    
    # Also make a fine grid that spans the observation window for plotting purposes
    t = np.linspace(x.min() - 5, x.max() + 5, 1000)
    
    plt.errorbar(x, y, yerr=yerr, fmt=".k")
    plt.xlabel("time [days]")
    _ = plt.ylabel("radial velocity [m/s]")



.. image:: rv_files/rv_4_0.png


Now, we know the periods and transit times for the planets `from the K2
light curve <https://arxiv.org/abs/1511.04497>`__, so let’s start by
using the :func:`exoplanet.estimate_semi_amplitude` function to
estimate the expected RV semi-amplitudes for the planets.

.. code:: python

    import exoplanet as xo
    
    periods = [20.8851, 42.3633]
    period_errs = [0.0003, 0.0006]
    t0s = [2072.7948, 2082.6251]
    t0_errs = [0.0007, 0.0004]
    Ks = xo.estimate_semi_amplitude(periods, x, y, yerr, t0s=t0s)
    print(Ks, "m/s")


.. parsed-literal::

    [5.05069163 5.50983542] m/s


The radial velocity model in PyMC3
----------------------------------

Now that we have the data and an estimate of the initial values for the
parameters, let’s start defining the probabilistic model in PyMC3 (take
a look at :ref:`intro-to-pymc3` if you’re new to PyMC3). First, we’ll
define our priors on the parameters:

.. code:: python

    import pymc3 as pm
    import theano.tensor as tt
    
    with pm.Model() as model:
    
        # Gaussian priors based on transit data (from Petigura et al.)
        t0 = pm.Normal("t0", mu=np.array(t0s), sd=np.array(t0_errs), shape=2)
        P = pm.Bound(pm.Normal, lower=0)(
            "P",
            mu=np.array(periods),
            sd=np.array(period_errs),
            shape=2,
            testval=np.array(periods),
        )
    
        # Wide log-normal prior for semi-amplitude
        logK = pm.Bound(pm.Normal, lower=0)(
            "logK", mu=np.log(Ks), sd=10.0, shape=2, testval=np.log(Ks)
        )
    
        # Eccentricity & argument of periasteron
        ecc = xo.distributions.UnitUniform(
            "ecc", shape=2, testval=np.array([0.1, 0.1])
        )
        omega = xo.distributions.Angle("omega", shape=2)
    
        # Jitter & a quadratic RV trend
        logs = pm.Normal("logs", mu=np.log(np.median(yerr)), sd=5.0)
        trend = pm.Normal("trend", mu=0, sd=10.0 ** -np.arange(3)[::-1], shape=3)
    
        # Then we define the orbit
        orbit = xo.orbits.KeplerianOrbit(period=P, t0=t0, ecc=ecc, omega=omega)
    
        # And a function for computing the full RV model
        def get_rv_model(t, name=""):
            # First the RVs induced by the planets
            vrad = orbit.get_radial_velocity(t, K=tt.exp(logK))
            pm.Deterministic("vrad" + name, vrad)
    
            # Define the background model
            A = np.vander(t - x_ref, 3)
            bkg = pm.Deterministic("bkg" + name, tt.dot(A, trend))
    
            # Sum over planets and add the background to get the full model
            return pm.Deterministic("rv_model" + name, tt.sum(vrad, axis=-1) + bkg)
    
        # Define the RVs at the observed times
        rv_model = get_rv_model(x)
    
        # Also define the model on a fine grid as computed above (for plotting)
        rv_model_pred = get_rv_model(t, name="_pred")
    
        # Finally add in the observation model. This next line adds a new contribution
        # to the log probability of the PyMC3 model
        err = tt.sqrt(yerr ** 2 + tt.exp(2 * logs))
        pm.Normal("obs", mu=rv_model, sd=err, observed=y)

Now, we can plot the initial model:

.. code:: python

    plt.errorbar(x, y, yerr=yerr, fmt=".k")
    
    with model:
        plt.plot(t, xo.eval_in_model(model.vrad_pred), "--k", alpha=0.5)
        plt.plot(t, xo.eval_in_model(model.bkg_pred), ":k", alpha=0.5)
        plt.plot(t, xo.eval_in_model(model.rv_model_pred), label="model")
    
    plt.legend(fontsize=10)
    plt.xlim(t.min(), t.max())
    plt.xlabel("time [days]")
    plt.ylabel("radial velocity [m/s]")
    _ = plt.title("initial model")


.. parsed-literal::

    WARNING (theano.tensor.blas): We did not find a dynamic library in the library_dir of the library we use for blas. If you use ATLAS, make sure to compile it with dynamics library.
    WARNING (theano.tensor.blas): We did not find a dynamic library in the library_dir of the library we use for blas. If you use ATLAS, make sure to compile it with dynamics library.



.. image:: rv_files/rv_10_1.png


In this plot, the background is the dotted line, the individual planets
are the dashed lines, and the full model is the blue line.

It doesn’t look amazing so let’s fit for the maximum a posterior
parameters.

.. code:: python

    with model:
        map_soln = xo.optimize(start=model.test_point, vars=[trend])
        map_soln = xo.optimize(start=map_soln)


.. parsed-literal::

    optimizing logp for variables: [trend]
    13it [00:04,  3.23it/s, logp=-6.484820e+01] 
    message: Optimization terminated successfully.
    logp: -79.73266285618837 -> -64.8482026233154
    optimizing logp for variables: [trend, logs, omega, ecc, logK, P, t0]
    181it [00:00, 276.00it/s, logp=-1.427676e+01]
    message: Desired error not necessarily achieved due to precision loss.
    logp: -64.8482026233154 -> -14.276760262380833


.. code:: python

    plt.errorbar(x, y, yerr=yerr, fmt=".k")
    plt.plot(t, map_soln["vrad_pred"], "--k", alpha=0.5)
    plt.plot(t, map_soln["bkg_pred"], ":k", alpha=0.5)
    plt.plot(t, map_soln["rv_model_pred"], label="model")
    
    plt.legend(fontsize=10)
    plt.xlim(t.min(), t.max())
    plt.xlabel("time [days]")
    plt.ylabel("radial velocity [m/s]")
    _ = plt.title("MAP model")



.. image:: rv_files/rv_13_0.png


That looks better.

Sampling
--------

Now that we have our model set up and a good estimate of the initial
parameters, let’s start sampling. There are substantial covariances
between some of the parameters so we’ll use a
:func:`exoplanet.get_dense_nuts_step` to tune the sampler (see the
:ref:`pymc3-extras` tutorial for more information).

.. code:: python

    np.random.seed(42)
    with model:
        trace = pm.sample(
            tune=4000,
            draws=4000,
            cores=2,
            chains=2,
            step=xo.get_dense_nuts_step(target_accept=0.95),
        )


.. parsed-literal::

    Multiprocess sampling (2 chains in 2 jobs)
    NUTS: [trend, logs, omega, ecc, logK, P, t0]
    Sampling 2 chains, 1 divergences: 100%|██████████| 16000/16000 [02:39<00:00, 100.42draws/s]
    There was 1 divergence after tuning. Increase `target_accept` or reparameterize.
    The number of effective samples is smaller than 25% for some parameters.


After sampling, it’s always a good idea to do some convergence checks.
First, let’s check the number of effective samples and the Gelman-Rubin
statistic for our parameters of interest:

.. code:: python

    pm.summary(
        trace, varnames=["trend", "logs", "omega", "ecc", "t0", "logK", "P"]
    )




.. raw:: html

    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }
    
        .dataframe tbody tr th {
            vertical-align: top;
        }
    
        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>mean</th>
          <th>sd</th>
          <th>hpd_3%</th>
          <th>hpd_97%</th>
          <th>mcse_mean</th>
          <th>mcse_sd</th>
          <th>ess_mean</th>
          <th>ess_sd</th>
          <th>ess_bulk</th>
          <th>ess_tail</th>
          <th>r_hat</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>trend[0]</th>
          <td>0.001</td>
          <td>0.001</td>
          <td>-0.000</td>
          <td>0.002</td>
          <td>0.000</td>
          <td>0.000</td>
          <td>4667.0</td>
          <td>3786.0</td>
          <td>4673.0</td>
          <td>4693.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>trend[1]</th>
          <td>-0.038</td>
          <td>0.023</td>
          <td>-0.082</td>
          <td>0.005</td>
          <td>0.000</td>
          <td>0.000</td>
          <td>6140.0</td>
          <td>5780.0</td>
          <td>6215.0</td>
          <td>4078.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>trend[2]</th>
          <td>-1.950</td>
          <td>0.799</td>
          <td>-3.353</td>
          <td>-0.378</td>
          <td>0.011</td>
          <td>0.008</td>
          <td>5425.0</td>
          <td>5425.0</td>
          <td>5475.0</td>
          <td>6148.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>logs</th>
          <td>1.043</td>
          <td>0.224</td>
          <td>0.622</td>
          <td>1.461</td>
          <td>0.004</td>
          <td>0.003</td>
          <td>3182.0</td>
          <td>3130.0</td>
          <td>3176.0</td>
          <td>4515.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>omega[0]</th>
          <td>-0.294</td>
          <td>0.826</td>
          <td>-1.530</td>
          <td>1.462</td>
          <td>0.021</td>
          <td>0.020</td>
          <td>1520.0</td>
          <td>872.0</td>
          <td>1730.0</td>
          <td>1298.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>omega[1]</th>
          <td>-0.707</td>
          <td>2.084</td>
          <td>-3.127</td>
          <td>2.866</td>
          <td>0.041</td>
          <td>0.030</td>
          <td>2623.0</td>
          <td>2375.0</td>
          <td>4104.0</td>
          <td>6625.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>ecc[0]</th>
          <td>0.235</td>
          <td>0.116</td>
          <td>0.000</td>
          <td>0.417</td>
          <td>0.002</td>
          <td>0.002</td>
          <td>2644.0</td>
          <td>2644.0</td>
          <td>2153.0</td>
          <td>1165.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>ecc[1]</th>
          <td>0.201</td>
          <td>0.148</td>
          <td>0.000</td>
          <td>0.466</td>
          <td>0.003</td>
          <td>0.002</td>
          <td>1825.0</td>
          <td>1801.0</td>
          <td>1813.0</td>
          <td>2707.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>t0[0]</th>
          <td>2072.795</td>
          <td>0.001</td>
          <td>2072.794</td>
          <td>2072.796</td>
          <td>0.000</td>
          <td>0.000</td>
          <td>8172.0</td>
          <td>8172.0</td>
          <td>8180.0</td>
          <td>5819.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>t0[1]</th>
          <td>2082.625</td>
          <td>0.000</td>
          <td>2082.624</td>
          <td>2082.626</td>
          <td>0.000</td>
          <td>0.000</td>
          <td>8260.0</td>
          <td>8260.0</td>
          <td>8266.0</td>
          <td>5899.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>logK[0]</th>
          <td>1.550</td>
          <td>0.256</td>
          <td>1.043</td>
          <td>1.975</td>
          <td>0.007</td>
          <td>0.005</td>
          <td>1489.0</td>
          <td>1489.0</td>
          <td>2053.0</td>
          <td>1303.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>logK[1]</th>
          <td>1.569</td>
          <td>0.240</td>
          <td>1.131</td>
          <td>2.014</td>
          <td>0.004</td>
          <td>0.003</td>
          <td>3126.0</td>
          <td>3126.0</td>
          <td>3933.0</td>
          <td>2758.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>P[0]</th>
          <td>20.885</td>
          <td>0.000</td>
          <td>20.885</td>
          <td>20.886</td>
          <td>0.000</td>
          <td>0.000</td>
          <td>9177.0</td>
          <td>9177.0</td>
          <td>9178.0</td>
          <td>6234.0</td>
          <td>1.0</td>
        </tr>
        <tr>
          <th>P[1]</th>
          <td>42.363</td>
          <td>0.001</td>
          <td>42.362</td>
          <td>42.364</td>
          <td>0.000</td>
          <td>0.000</td>
          <td>8775.0</td>
          <td>8775.0</td>
          <td>8774.0</td>
          <td>5951.0</td>
          <td>1.0</td>
        </tr>
      </tbody>
    </table>
    </div>



It looks like everything is pretty much converged here. Not bad for 14
parameters and about a minute of runtime…

Then we can make a `corner plot <https://corner.readthedocs.io>`__ of
any combination of the parameters. For example, let’s look at period,
semi-amplitude, and eccentricity:

.. code:: python

    import corner
    
    samples = pm.trace_to_dataframe(trace, varnames=["P", "logK", "ecc", "omega"])
    _ = corner.corner(samples)



.. image:: rv_files/rv_19_0.png


Finally, let’s plot the plosterior constraints on the RV model and
compare those to the data:

.. code:: python

    plt.errorbar(x, y, yerr=yerr, fmt=".k")
    
    # Compute the posterior predictions for the RV model
    pred = np.percentile(trace["rv_model_pred"], [16, 50, 84], axis=0)
    plt.plot(t, pred[1], color="C0", label="model")
    art = plt.fill_between(t, pred[0], pred[2], color="C0", alpha=0.3)
    art.set_edgecolor("none")
    
    plt.legend(fontsize=10)
    plt.xlim(t.min(), t.max())
    plt.xlabel("time [days]")
    plt.ylabel("radial velocity [m/s]")
    _ = plt.title("posterior constraints")



.. image:: rv_files/rv_21_0.png


Phase plots
-----------

It might be also be interesting to look at the phased plots for this
system. Here we’ll fold the dataset on the median of posterior period
and then overplot the posterior constraint on the folded model orbits.

.. code:: python

    for n, letter in enumerate("bc"):
        plt.figure()
    
        # Get the posterior median orbital parameters
        p = np.median(trace["P"][:, n])
        t0 = np.median(trace["t0"][:, n])
    
        # Compute the median of posterior estimate of the background RV
        # and the contribution from the other planet. Then we can remove
        # this from the data to plot just the planet we care about.
        other = np.median(trace["vrad"][:, :, (n + 1) % 2], axis=0)
        other += np.median(trace["bkg"], axis=0)
    
        # Plot the folded data
        x_fold = (x - t0 + 0.5 * p) % p - 0.5 * p
        plt.errorbar(x_fold, y - other, yerr=yerr, fmt=".k")
    
        # Compute the posterior prediction for the folded RV model for this
        # planet
        t_fold = (t - t0 + 0.5 * p) % p - 0.5 * p
        inds = np.argsort(t_fold)
        pred = np.percentile(trace["vrad_pred"][:, inds, n], [16, 50, 84], axis=0)
        plt.plot(t_fold[inds], pred[1], color="C0", label="model")
        art = plt.fill_between(
            t_fold[inds], pred[0], pred[2], color="C0", alpha=0.3
        )
        art.set_edgecolor("none")
    
        plt.legend(fontsize=10)
        plt.xlim(-0.5 * p, 0.5 * p)
        plt.xlabel("phase [days]")
        plt.ylabel("radial velocity [m/s]")
        plt.title("K2-24{0}".format(letter))



.. image:: rv_files/rv_23_0.png



.. image:: rv_files/rv_23_1.png


Citations
---------

As described in the :ref:`citation` tutorial, we can use
:func:`exoplanet.citations.get_citations_for_model` to construct an
acknowledgement and BibTeX listing that includes the relevant citations
for this model.

.. code:: python

    with model:
        txt, bib = xo.citations.get_citations_for_model()
    print(txt)


.. parsed-literal::

    This research made use of \textsf{exoplanet} \citep{exoplanet} and its
    dependencies \citep{exoplanet:astropy13, exoplanet:astropy18,
    exoplanet:exoplanet, exoplanet:pymc3, exoplanet:theano}.


.. code:: python

    print("\n".join(bib.splitlines()[:10]) + "\n...")


.. parsed-literal::

    
    @misc{exoplanet:exoplanet,
      author = {Daniel Foreman-Mackey and Ian Czekala and Rodrigo Luger and
                Eric Agol and Geert Barentsen and Tom Barclay},
       title = {exoplanet-dev/exoplanet v0.3.0},
       month = apr,
        year = 2020,
         doi = {10.5281/zenodo.1998447},
         url = {https://doi.org/10.5281/zenodo.1998447}
    }
    ...


